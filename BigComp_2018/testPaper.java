
package BigComp_2018;

/*
	改试卷
	在上小学的时候，我们经常碰到这样的事:考完试后老师懒得改试卷，于是让我们同桌相互交换试卷后为对方批改。但是后来老师发现这样作容易出现作弊，于是他想了一个新办法。 老师将同学分成了 n 个组，其中编号为??的组中有????个人。然后老师会按某种顺序依次访问 这些组。 对于他访问的第一个组，他会将这组内的所有试卷都收走，放置在桌上;对于他后续访问的每一个组，首先他会从桌上的试卷最上方拿出该组对应人数数量的试卷，随机分配给该组每 个人一张试卷让他们进行批改，而后再将这组学生自己考的试卷收走放置在桌面试卷的最下 方。当他访问完所有的组后他会将桌面上剩余的所有试卷随机分配给他第一个访问的组的学生进行批改。 但他发现这种方法有时候也会出现问题:有可能在中途访问到某个组的时候桌面上的试卷不够分配给这组学生每人一张;也有可能最后会有学生分配到批改自己的试卷，而且这两种情 况是否出现是与他访问每个组的顺序有关的。现在他想知道是否存在一种访问顺序能够使以 上两种情况都不出现，顺利完成试卷批改呢?

	输入描述:
	第一行包含一个整数??，表示学生组数。2 ≤ ?? ≤ 30
	第二行包含??个整数，??1,??2,...,????，分别表示每组学生的人数。1≤???? ≤10000


	输出描述:
	若存在一种访问顺序能使试卷顺利批改完成，输出 Yes，否则输出 No。
	示例1
	输入
	2
	10 20
	输出
	No
	示例2
	输入
	4
	2 3 3 1
	输出
	Yes
	说明
	我们可以选择先访问人数为 3 的组，再访问人数为 3 的组，再访问人数
	为 1 的组，最后访问人数为 2 的组。
 */

//第一种情况，只要最大值不大于剩余的人数就可以
//第二种情况，只要每次选择剩余组中最大的一组就可以。
import java.io.*;
import java.lang.reflect.Array;
import java.util.*;
public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        bf.readLine();
        int sum = 0, max = 0;
        for(String s: bf.readLine().split(" ")){
            int num = Integer.parseInt(s);
            sum += num;
            max = num>max? num: max;
        }
        System.out.println(max > sum-max ? "No":"Yes");
    }
}
